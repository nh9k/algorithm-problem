; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27032.1 

	TITLE	C:\Users\Nanhee\source\repos2020up\baek-gm2\baek-gm2\baek-gm2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?N@@3HA						; N
PUBLIC	?realmap@@3PAY0BE@HA				; realmap
PUBLIC	?checkmap@@3PAY0BE@_NA				; checkmap
PUBLIC	?sum@@3PAHA					; sum
PUBLIC	?allsum@@3HA					; allsum
PUBLIC	?result@@3HA					; result
_BSS	SEGMENT
?N@@3HA	DD	01H DUP (?)				; N
?realmap@@3PAY0BE@HA DD 0190H DUP (?)			; realmap
?checkmap@@3PAY0BE@_NA DB 0190H DUP (?)			; checkmap
?sum@@3PAHA DD	05H DUP (?)				; sum
?allsum@@3HA DD	01H DUP (?)				; allsum
?result@@3HA DD	01H DUP (?)				; result
_BSS	ENDS
msvcjmc	SEGMENT
__6BC0FD35_vcruntime_new@h DB 01H
__A73354DD_stdlib@h DB 01H
__188180DA_corecrt_math@h DB 01H
__D23EE329_cstdlib DB 01H
__3736D25A_xtgmath@h DB 01H
__824D367B_cmath DB 01H
__2CC6E67D_corecrt_stdio_config@h DB 01H
__05476D76_corecrt_wstdio@h DB 01H
__A452D4A0_stdio@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__2088847F_corecrt_memory@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__5ECFF36E_type_traits DB 01H
__331E732B_malloc@h DB 01H
__9BB4E194_vcruntime_exception@h DB 01H
__7949CB39_exception DB 01H
__41381B41_corecrt_wconio@h DB 01H
__F0CC4AC4_corecrt_wio@h DB 01H
__C0802A2B_corecrt_wtime@h DB 01H
__A40A425D_stat@h DB 01H
__5A74375D_wchar@h DB 01H
__B2D003D7_limits DB 01H
__7E39D651_iosfwd DB 01H
__CDB00636_xutility DB 01H
__C334353D_xatomic0@h DB 01H
__1CE3C767_xmemory0 DB 01H
__F007F164_stdexcept DB 01H
__C42C8B73_vcruntime_typeinfo@h DB 01H
__7B7A869E_ctype@h DB 01H
__A2E616E7_xlocinfo DB 01H
__0E7E0F59_memory DB 01H
__223B5856_xfacet DB 01H
__244BF7CC_xlocale DB 01H
__420D52D3_xcall_once@h DB 01H
__FD5040F3_system_error DB 01H
__9B0361F4_xiosbase DB 01H
__BACC91DB_xlocnum DB 01H
__D1FEDD45_ios DB 01H
__8DC6A792_baek-gm2@cpp DB 01H
__FB7583FD_xstring DB 01H
__548B1832_istream DB 01H
__375B2D08_ostream DB 01H
__F2A749D8_streambuf DB 01H
__E53366A2_utility DB 01H
__122CF1B0_xstddef DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?check5sum@@YAXHHHH@Z				; check5sum
PUBLIC	?checkallsum@@YAXHHHH@Z				; checkallsum
PUBLIC	?isresult@@YAXXZ				; isresult
PUBLIC	_main
PUBLIC	__JustMyCode_Default
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nanhee\source\repos2020up\baek-gm2\baek-gm2\baek-gm2.cpp
;	COMDAT _main
_TEXT	SEGMENT
_d2$1 = -68						; size = 4
_d1$2 = -56						; size = 4
_y$3 = -44						; size = 4
_x$4 = -32						; size = 4
_j$5 = -20						; size = 4
_i$6 = -8						; size = 4
_main	PROC						; COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8DC6A792_baek-gm2@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 141  : 	cin >> N;

	mov	esi, esp
	push	OFFSET ?N@@3HA				; N
	mov	ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 142  : 	for (int i = 0; i < N; ++i)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN4@main:
	mov	eax, DWORD PTR _i$6[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN3@main

; 143  : 	{
; 144  : 		for (int j = 0; j < N; ++j)

	mov	DWORD PTR _j$5[ebp], 0
	jmp	SHORT $LN7@main
$LN5@main:
	mov	eax, DWORD PTR _j$5[ebp]
	add	eax, 1
	mov	DWORD PTR _j$5[ebp], eax
$LN7@main:
	mov	eax, DWORD PTR _j$5[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN6@main

; 145  : 		{
; 146  : 			cin >> realmap[i][j];

	imul	eax, DWORD PTR _i$6[ebp], 80
	mov	ecx, DWORD PTR _j$5[ebp]
	lea	edx, DWORD PTR ?realmap@@3PAY0BE@HA[eax+ecx*4]
	mov	esi, esp
	push	edx
	mov	ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 147  : 			allsum += realmap[i][j];

	imul	eax, DWORD PTR _i$6[ebp], 80
	mov	ecx, DWORD PTR _j$5[ebp]
	mov	edx, DWORD PTR ?allsum@@3HA		; allsum
	add	edx, DWORD PTR ?realmap@@3PAY0BE@HA[eax+ecx*4]
	mov	DWORD PTR ?allsum@@3HA, edx		; allsum

; 148  : 		}

	jmp	SHORT $LN5@main
$LN6@main:

; 149  : 	}

	jmp	SHORT $LN2@main
$LN3@main:

; 150  : 
; 151  : 	result = 40000;

	mov	DWORD PTR ?result@@3HA, 40000		; result, 00009c40H

; 152  : 	//determine x, y, d1, d2
; 153  : 	for (int x = 0; x < N; ++x)

	mov	DWORD PTR _x$4[ebp], 0
	jmp	SHORT $LN10@main
$LN8@main:
	mov	eax, DWORD PTR _x$4[ebp]
	add	eax, 1
	mov	DWORD PTR _x$4[ebp], eax
$LN10@main:
	mov	eax, DWORD PTR _x$4[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	$LN9@main

; 154  : 	{
; 155  : 		for (int y = 0; y < N; ++y)

	mov	DWORD PTR _y$3[ebp], 0
	jmp	SHORT $LN13@main
$LN11@main:
	mov	eax, DWORD PTR _y$3[ebp]
	add	eax, 1
	mov	DWORD PTR _y$3[ebp], eax
$LN13@main:
	mov	eax, DWORD PTR _y$3[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	$LN12@main

; 156  : 		{
; 157  : 			//if (((x == 0) && (y == 0)) || ((x == N - 1) && (y == 0)) || ((x == 0) && (y == N - 1)) || ((x == N - 1) && (y == N - 1))) continue;
; 158  : 			for (int d1 = 1; (x + d1 < N - 1)&&(y - d1 >= 0); ++d1)

	mov	DWORD PTR _d1$2[ebp], 1
	jmp	SHORT $LN16@main
$LN14@main:
	mov	eax, DWORD PTR _d1$2[ebp]
	add	eax, 1
	mov	DWORD PTR _d1$2[ebp], eax
$LN16@main:
	mov	eax, DWORD PTR _x$4[ebp]
	add	eax, DWORD PTR _d1$2[ebp]
	mov	ecx, DWORD PTR ?N@@3HA			; N
	sub	ecx, 1
	cmp	eax, ecx
	jge	SHORT $LN15@main
	mov	eax, DWORD PTR _y$3[ebp]
	sub	eax, DWORD PTR _d1$2[ebp]
	js	SHORT $LN15@main

; 159  : 			{
; 160  : 				for (int d2 = 1; (x + d1 + d2 < N) && (y + d2 < N); ++d2)

	mov	DWORD PTR _d2$1[ebp], 1
	jmp	SHORT $LN19@main
$LN17@main:
	mov	eax, DWORD PTR _d2$1[ebp]
	add	eax, 1
	mov	DWORD PTR _d2$1[ebp], eax
$LN19@main:
	mov	eax, DWORD PTR _x$4[ebp]
	add	eax, DWORD PTR _d1$2[ebp]
	add	eax, DWORD PTR _d2$1[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN18@main
	mov	eax, DWORD PTR _y$3[ebp]
	add	eax, DWORD PTR _d2$1[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN18@main

; 161  : 				{
; 162  : 					//printmap();
; 163  : 					check5sum(x, y, d1, d2);

	mov	eax, DWORD PTR _d2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _d1$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$3[ebp]
	push	edx
	mov	eax, DWORD PTR _x$4[ebp]
	push	eax
	call	?check5sum@@YAXHHHH@Z			; check5sum
	add	esp, 16					; 00000010H

; 164  : 					//printmap();
; 165  : 					checkallsum(x, y, d1, d2);

	mov	eax, DWORD PTR _d2$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _d1$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$3[ebp]
	push	edx
	mov	eax, DWORD PTR _x$4[ebp]
	push	eax
	call	?checkallsum@@YAXHHHH@Z			; checkallsum
	add	esp, 16					; 00000010H

; 166  : 					isresult();

	call	?isresult@@YAXXZ			; isresult

; 167  : 				}

	jmp	SHORT $LN17@main
$LN18@main:

; 168  : 			}

	jmp	$LN14@main
$LN15@main:

; 169  : 		}

	jmp	$LN11@main
$LN12@main:

; 170  : 	}

	jmp	$LN8@main
$LN9@main:

; 171  : 
; 172  : 	cout << result;

	mov	esi, esp
	mov	eax, DWORD PTR ?result@@3HA		; result
	push	eax
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 173  : }

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nanhee\source\repos2020up\baek-gm2\baek-gm2\baek-gm2.cpp
;	COMDAT ?isresult@@YAXXZ
_TEXT	SEGMENT
_j$1 = -56						; size = 4
_i$2 = -44						; size = 4
_chk$3 = -32						; size = 4
_maxvalue$ = -20					; size = 4
_minvalue$ = -8						; size = 4
?isresult@@YAXXZ PROC					; isresult, COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8DC6A792_baek-gm2@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 111  : 	int minvalue = 40000;

	mov	DWORD PTR _minvalue$[ebp], 40000	; 00009c40H

; 112  : 	int maxvalue = 0;

	mov	DWORD PTR _maxvalue$[ebp], 0

; 113  : 	for (int chk = 0; chk < 5; ++chk)

	mov	DWORD PTR _chk$3[ebp], 0
	jmp	SHORT $LN4@isresult
$LN2@isresult:
	mov	eax, DWORD PTR _chk$3[ebp]
	add	eax, 1
	mov	DWORD PTR _chk$3[ebp], eax
$LN4@isresult:
	cmp	DWORD PTR _chk$3[ebp], 5
	jge	SHORT $LN3@isresult

; 114  : 	{
; 115  : 		if (sum[chk] < minvalue)

	mov	eax, DWORD PTR _chk$3[ebp]
	mov	ecx, DWORD PTR ?sum@@3PAHA[eax*4]
	cmp	ecx, DWORD PTR _minvalue$[ebp]
	jge	SHORT $LN11@isresult

; 116  : 			minvalue = sum[chk];

	mov	eax, DWORD PTR _chk$3[ebp]
	mov	ecx, DWORD PTR ?sum@@3PAHA[eax*4]
	mov	DWORD PTR _minvalue$[ebp], ecx
$LN11@isresult:

; 117  : 		if (sum[chk] > maxvalue)

	mov	eax, DWORD PTR _chk$3[ebp]
	mov	ecx, DWORD PTR ?sum@@3PAHA[eax*4]
	cmp	ecx, DWORD PTR _maxvalue$[ebp]
	jle	SHORT $LN12@isresult

; 118  : 			maxvalue = sum[chk];

	mov	eax, DWORD PTR _chk$3[ebp]
	mov	ecx, DWORD PTR ?sum@@3PAHA[eax*4]
	mov	DWORD PTR _maxvalue$[ebp], ecx
$LN12@isresult:

; 119  : 		//initialize
; 120  : 		//cout << sum[chk] << " ";
; 121  : 		sum[chk] = 0;

	mov	eax, DWORD PTR _chk$3[ebp]
	mov	DWORD PTR ?sum@@3PAHA[eax*4], 0

; 122  : 	}

	jmp	SHORT $LN2@isresult
$LN3@isresult:

; 123  : 	if (result > (maxvalue - minvalue))

	mov	eax, DWORD PTR _maxvalue$[ebp]
	sub	eax, DWORD PTR _minvalue$[ebp]
	cmp	DWORD PTR ?result@@3HA, eax		; result
	jle	SHORT $LN13@isresult

; 124  : 		result = maxvalue - minvalue;

	mov	eax, DWORD PTR _maxvalue$[ebp]
	sub	eax, DWORD PTR _minvalue$[ebp]
	mov	DWORD PTR ?result@@3HA, eax		; result
$LN13@isresult:

; 125  : 
; 126  : 	//cout << endl << maxvalue - minvalue << endl;
; 127  : 	//initialize
; 128  : 	for (int i = 0; i < N; ++i)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN7@isresult
$LN5@isresult:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN7@isresult:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN1@isresult

; 129  : 	{
; 130  : 		for (int j = 0; j < N; ++j)

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN10@isresult
$LN8@isresult:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN10@isresult:
	mov	eax, DWORD PTR _j$1[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN9@isresult

; 131  : 		{
; 132  : 			checkmap[i][j] = false;

	imul	eax, DWORD PTR _i$2[ebp], 20
	mov	ecx, DWORD PTR _j$1[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 0

; 133  : 		}

	jmp	SHORT $LN8@isresult
$LN9@isresult:

; 134  : 	}

	jmp	SHORT $LN5@isresult
$LN1@isresult:

; 135  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?isresult@@YAXXZ ENDP					; isresult
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nanhee\source\repos2020up\baek-gm2\baek-gm2\baek-gm2.cpp
;	COMDAT ?checkallsum@@YAXHHHH@Z
_TEXT	SEGMENT
_j$1 = -92						; size = 4
_i$2 = -80						; size = 4
_j$3 = -68						; size = 4
_i$4 = -56						; size = 4
_j$5 = -44						; size = 4
_i$6 = -32						; size = 4
_j$7 = -20						; size = 4
_i$8 = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_d1$ = 16						; size = 4
_d2$ = 20						; size = 4
?checkallsum@@YAXHHHH@Z PROC				; checkallsum, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8DC6A792_baek-gm2@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 64   : 	for (int i = 0; i < x + d1; ++i) //1선거구

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN4@checkallsu
$LN2@checkallsu:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN4@checkallsu:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d1$[ebp]
	cmp	DWORD PTR _i$8[ebp], eax
	jge	SHORT $LN3@checkallsu

; 65   : 	{
; 66   : 		for (int j = 0; j <= y; ++j)

	mov	DWORD PTR _j$7[ebp], 0
	jmp	SHORT $LN7@checkallsu
$LN5@checkallsu:
	mov	eax, DWORD PTR _j$7[ebp]
	add	eax, 1
	mov	DWORD PTR _j$7[ebp], eax
$LN7@checkallsu:
	mov	eax, DWORD PTR _j$7[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jg	SHORT $LN6@checkallsu

; 67   : 		{
; 68   : 			if (checkmap[i][j] == true) break;

	imul	eax, DWORD PTR _i$8[ebp], 20
	mov	ecx, DWORD PTR _j$7[ebp]
	movzx	edx, BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx]
	cmp	edx, 1
	jne	SHORT $LN26@checkallsu
	jmp	SHORT $LN6@checkallsu
$LN26@checkallsu:

; 69   : 			checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$8[ebp], 20
	mov	ecx, DWORD PTR _j$7[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 70   : 			sum[0] += realmap[i][j];

	mov	eax, 4
	imul	ecx, eax, 0
	imul	edx, DWORD PTR _i$8[ebp], 80
	mov	eax, DWORD PTR ?sum@@3PAHA[ecx]
	mov	ecx, DWORD PTR _j$7[ebp]
	add	eax, DWORD PTR ?realmap@@3PAY0BE@HA[edx+ecx*4]
	mov	edx, 4
	imul	ecx, edx, 0
	mov	DWORD PTR ?sum@@3PAHA[ecx], eax

; 71   : 		}

	jmp	SHORT $LN5@checkallsu
$LN6@checkallsu:

; 72   : 	}

	jmp	$LN2@checkallsu
$LN3@checkallsu:

; 73   : 	//printmap();
; 74   : 	for (int i = 0; i <= x + d2; ++i) //2선거구

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN10@checkallsu
$LN8@checkallsu:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN10@checkallsu:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _i$6[ebp], eax
	jg	SHORT $LN9@checkallsu

; 75   : 	{
; 76   : 		for (int j = N - 1; j > y; --j)

	mov	eax, DWORD PTR ?N@@3HA			; N
	sub	eax, 1
	mov	DWORD PTR _j$5[ebp], eax
	jmp	SHORT $LN13@checkallsu
$LN11@checkallsu:
	mov	eax, DWORD PTR _j$5[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$5[ebp], eax
$LN13@checkallsu:
	mov	eax, DWORD PTR _j$5[ebp]
	cmp	eax, DWORD PTR _y$[ebp]
	jle	SHORT $LN12@checkallsu

; 77   : 		{
; 78   : 			if (checkmap[i][j] == true) break;

	imul	eax, DWORD PTR _i$6[ebp], 20
	mov	ecx, DWORD PTR _j$5[ebp]
	movzx	edx, BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx]
	cmp	edx, 1
	jne	SHORT $LN27@checkallsu
	jmp	SHORT $LN12@checkallsu
$LN27@checkallsu:

; 79   : 			checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$6[ebp], 20
	mov	ecx, DWORD PTR _j$5[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 80   : 			sum[1] += realmap[i][j];

	mov	eax, 4
	shl	eax, 0
	imul	ecx, DWORD PTR _i$6[ebp], 80
	mov	edx, DWORD PTR ?sum@@3PAHA[eax]
	mov	eax, DWORD PTR _j$5[ebp]
	add	edx, DWORD PTR ?realmap@@3PAY0BE@HA[ecx+eax*4]
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR ?sum@@3PAHA[ecx], edx

; 81   : 		}

	jmp	SHORT $LN11@checkallsu
$LN12@checkallsu:

; 82   : 	}

	jmp	$LN8@checkallsu
$LN9@checkallsu:

; 83   : 	//printmap();
; 84   : 	for (int i = x+d1; i < N; ++i) //3선거구

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d1$[ebp]
	mov	DWORD PTR _i$4[ebp], eax
	jmp	SHORT $LN16@checkallsu
$LN14@checkallsu:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN16@checkallsu:
	mov	eax, DWORD PTR _i$4[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN15@checkallsu

; 85   : 	{
; 86   : 		for (int j = 0; j < y - d1 + d2; ++j)

	mov	DWORD PTR _j$3[ebp], 0
	jmp	SHORT $LN19@checkallsu
$LN17@checkallsu:
	mov	eax, DWORD PTR _j$3[ebp]
	add	eax, 1
	mov	DWORD PTR _j$3[ebp], eax
$LN19@checkallsu:
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _d1$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _j$3[ebp], eax
	jge	SHORT $LN18@checkallsu

; 87   : 		{
; 88   : 			if (checkmap[i][j] == true) break;

	imul	eax, DWORD PTR _i$4[ebp], 20
	mov	ecx, DWORD PTR _j$3[ebp]
	movzx	edx, BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx]
	cmp	edx, 1
	jne	SHORT $LN28@checkallsu
	jmp	SHORT $LN18@checkallsu
$LN28@checkallsu:

; 89   : 			checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$4[ebp], 20
	mov	ecx, DWORD PTR _j$3[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 90   : 			sum[2] += realmap[i][j];

	mov	eax, 4
	shl	eax, 1
	imul	ecx, DWORD PTR _i$4[ebp], 80
	mov	edx, DWORD PTR ?sum@@3PAHA[eax]
	mov	eax, DWORD PTR _j$3[ebp]
	add	edx, DWORD PTR ?realmap@@3PAY0BE@HA[ecx+eax*4]
	mov	ecx, 4
	shl	ecx, 1
	mov	DWORD PTR ?sum@@3PAHA[ecx], edx

; 91   : 		}

	jmp	SHORT $LN17@checkallsu
$LN18@checkallsu:

; 92   : 	}

	jmp	$LN14@checkallsu
$LN15@checkallsu:

; 93   : 	//printmap();
; 94   : 	for (int i = x + d2 + 1; i < N; ++i) //4선거구

	mov	eax, DWORD PTR _d2$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _i$2[ebp], edx
	jmp	SHORT $LN22@checkallsu
$LN20@checkallsu:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN22@checkallsu:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR ?N@@3HA			; N
	jge	SHORT $LN21@checkallsu

; 95   : 	{
; 96   : 		for (int j = N - 1; j >= y - d1 + d2; --j)

	mov	eax, DWORD PTR ?N@@3HA			; N
	sub	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
	jmp	SHORT $LN25@checkallsu
$LN23@checkallsu:
	mov	eax, DWORD PTR _j$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN25@checkallsu:
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _d1$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _j$1[ebp], eax
	jl	SHORT $LN24@checkallsu

; 97   : 		{
; 98   : 			if (checkmap[i][j] == true) break;

	imul	eax, DWORD PTR _i$2[ebp], 20
	mov	ecx, DWORD PTR _j$1[ebp]
	movzx	edx, BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx]
	cmp	edx, 1
	jne	SHORT $LN29@checkallsu
	jmp	SHORT $LN24@checkallsu
$LN29@checkallsu:

; 99   : 			checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$2[ebp], 20
	mov	ecx, DWORD PTR _j$1[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 100  : 			sum[3] += realmap[i][j];

	mov	eax, 4
	imul	ecx, eax, 3
	imul	edx, DWORD PTR _i$2[ebp], 80
	mov	eax, DWORD PTR ?sum@@3PAHA[ecx]
	mov	ecx, DWORD PTR _j$1[ebp]
	add	eax, DWORD PTR ?realmap@@3PAY0BE@HA[edx+ecx*4]
	mov	edx, 4
	imul	ecx, edx, 3
	mov	DWORD PTR ?sum@@3PAHA[ecx], eax

; 101  : 		}

	jmp	SHORT $LN23@checkallsu
$LN24@checkallsu:

; 102  : 	}

	jmp	$LN20@checkallsu
$LN21@checkallsu:

; 103  : 	//printmap();
; 104  : 	//5선거구
; 105  : 	sum[4] = allsum - (sum[0] + sum[1] + sum[2] + sum[3]);

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR ?sum@@3PAHA[ecx]
	add	eax, DWORD PTR ?sum@@3PAHA[edx]
	mov	ecx, 4
	shl	ecx, 1
	add	eax, DWORD PTR ?sum@@3PAHA[ecx]
	mov	edx, 4
	imul	ecx, edx, 3
	add	eax, DWORD PTR ?sum@@3PAHA[ecx]
	mov	edx, DWORD PTR ?allsum@@3HA		; allsum
	sub	edx, eax
	mov	eax, 4
	shl	eax, 2
	mov	DWORD PTR ?sum@@3PAHA[eax], edx

; 106  : 	//printmap();
; 107  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?checkallsum@@YAXHHHH@Z ENDP				; checkallsum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nanhee\source\repos2020up\baek-gm2\baek-gm2\baek-gm2.cpp
;	COMDAT ?check5sum@@YAXHHHH@Z
_TEXT	SEGMENT
_j$1 = -92						; size = 4
_i$2 = -80						; size = 4
_j$3 = -68						; size = 4
_i$4 = -56						; size = 4
_j$5 = -44						; size = 4
_i$6 = -32						; size = 4
_j$7 = -20						; size = 4
_i$8 = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_d1$ = 16						; size = 4
_d2$ = 20						; size = 4
?check5sum@@YAXHHHH@Z PROC				; check5sum, COMDAT

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8DC6A792_baek-gm2@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 41   : 	for (int i = x, j = y; (i <= x + d1)&&(j >= y - d1); ++i, --j)

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _i$8[ebp], eax
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _j$7[ebp], eax
	jmp	SHORT $LN4@check5sum
$LN2@check5sum:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
	mov	ecx, DWORD PTR _j$7[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$7[ebp], ecx
$LN4@check5sum:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d1$[ebp]
	cmp	DWORD PTR _i$8[ebp], eax
	jg	SHORT $LN3@check5sum
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _d1$[ebp]
	cmp	DWORD PTR _j$7[ebp], eax
	jl	SHORT $LN3@check5sum

; 42   : 	{
; 43   : 		checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$8[ebp], 20
	mov	ecx, DWORD PTR _j$7[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 44   : 	}

	jmp	SHORT $LN2@check5sum
$LN3@check5sum:

; 45   : 	for (int i = x, j = y; (i <= x + d2) && (j <= y + d2); ++i, ++j)

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _i$6[ebp], eax
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _j$5[ebp], eax
	jmp	SHORT $LN7@check5sum
$LN5@check5sum:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
	mov	ecx, DWORD PTR _j$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$5[ebp], ecx
$LN7@check5sum:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _i$6[ebp], eax
	jg	SHORT $LN6@check5sum
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _j$5[ebp], eax
	jg	SHORT $LN6@check5sum

; 46   : 	{
; 47   : 		if (checkmap[i][j] == true) continue;

	imul	eax, DWORD PTR _i$6[ebp], 20
	mov	ecx, DWORD PTR _j$5[ebp]
	movzx	edx, BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx]
	cmp	edx, 1
	jne	SHORT $LN14@check5sum
	jmp	SHORT $LN5@check5sum
$LN14@check5sum:

; 48   : 		checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$6[ebp], 20
	mov	ecx, DWORD PTR _j$5[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 49   : 	}

	jmp	SHORT $LN5@check5sum
$LN6@check5sum:

; 50   : 	for (int i = x + d1, j = y - d1; (i <= x + d1 + d2) && (j <= y - d1 + d2); ++i, ++j)

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d1$[ebp]
	mov	DWORD PTR _i$4[ebp], eax
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _d1$[ebp]
	mov	DWORD PTR _j$3[ebp], eax
	jmp	SHORT $LN10@check5sum
$LN8@check5sum:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
	mov	ecx, DWORD PTR _j$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$3[ebp], ecx
$LN10@check5sum:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d1$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _i$4[ebp], eax
	jg	SHORT $LN9@check5sum
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _d1$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _j$3[ebp], eax
	jg	SHORT $LN9@check5sum

; 51   : 	{
; 52   : 		if (checkmap[i][j] == true) continue;

	imul	eax, DWORD PTR _i$4[ebp], 20
	mov	ecx, DWORD PTR _j$3[ebp]
	movzx	edx, BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx]
	cmp	edx, 1
	jne	SHORT $LN15@check5sum
	jmp	SHORT $LN8@check5sum
$LN15@check5sum:

; 53   : 		checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$4[ebp], 20
	mov	ecx, DWORD PTR _j$3[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 54   : 	}

	jmp	SHORT $LN8@check5sum
$LN9@check5sum:

; 55   : 	for (int i = x + d2, j = y + d2; (i <= x + d1 + d2) && (j >= y +d2 - d1); ++i, --j)

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	mov	DWORD PTR _j$1[ebp], eax
	jmp	SHORT $LN13@check5sum
$LN11@check5sum:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
	mov	ecx, DWORD PTR _j$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$1[ebp], ecx
$LN13@check5sum:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _d1$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	cmp	DWORD PTR _i$2[ebp], eax
	jg	SHORT $LN1@check5sum
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _d2$[ebp]
	sub	eax, DWORD PTR _d1$[ebp]
	cmp	DWORD PTR _j$1[ebp], eax
	jl	SHORT $LN1@check5sum

; 56   : 	{
; 57   : 		if (checkmap[i][j] == true) continue;

	imul	eax, DWORD PTR _i$2[ebp], 20
	mov	ecx, DWORD PTR _j$1[ebp]
	movzx	edx, BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx]
	cmp	edx, 1
	jne	SHORT $LN16@check5sum
	jmp	SHORT $LN11@check5sum
$LN16@check5sum:

; 58   : 		checkmap[i][j] = true;

	imul	eax, DWORD PTR _i$2[ebp], 20
	mov	ecx, DWORD PTR _j$1[ebp]
	mov	BYTE PTR ?checkmap@@3PAY0BE@_NA[eax+ecx], 1

; 59   : 	}

	jmp	SHORT $LN11@check5sum
$LN1@check5sum:

; 60   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?check5sum@@YAXHHHH@Z ENDP				; check5sum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nanhee\source\repos2020up\baek-gm2\baek-gm2\baek-gm2.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8DC6A792_baek-gm2@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\nanhee\source\repos2020up\baek-gm2\baek-gm2\baek-gm2.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8DC6A792_baek-gm2@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
